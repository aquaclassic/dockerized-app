#!/usr/bin/env bash

# set the context to ./app|./node directory, its not going to save anything there, this is becouse to make sure proper
# references are made to files if specified in Dockerfile
# docker build -f ./docker/app/Dockerfile -t ajando/app:latest ./app
# docker build -f ./docker/node/Dockerfile -t ajando/node:latest ./node
# docker build -t ajando/app:latest --file $(pwd)/docker/app/Dockerfile $(pwd)/docker/app
# docker build -t ajando/app:latest --file $(pwd)/docker/node/Dockerfile $(pwd)/docker/node

# Bail out on first error 

set -e

# Get the directory of the build script 

DIR="$( cd "$( dirname "${BASH_SOURCE[0]}" )" && pwd )"

# Get the current git commit sha

HASH=$(git rev-parse HEAD)
echo $HASH
# Package the app

cd $DIR/../

# "archive" gives us useful tools -we can use .gitattributes
# to `export-ingore` extraneous files
# git downloaded your code and copyied it to /packaged
git archive --format=tar --worktree-attributes $HASH | tar -xf - -C $DIR/app/packaged



# Production Build Steps

## (Decision between export-ignore'ing docker/develop command or not)
## now you are in the packaged dir and do whatever it needs to be done
cd $DIR/app/packaged

./develop composer install --no-dev


# If your workflow needs any other building
# ./develop yarn install

# ./develop gulp --production

# Copy secrets from s3 bucket, .env suitable for production and copy it to .env
# /var/lib/jenkins/.venv/bin/aws s3 cp s3://shippingdocker-secrets/env-prod .env # you need this depending on dev

cd $DIR/app

docker build -t ajando/app:latest -t ajando/app:$HASH .

# Clean up packaged directory 
cd $DIR/app/packaged

PWD=$(pwd)

if [ "$PWD" == "$DIR/app/packaged" ]; then 
  rm -rf `ls -Ab`
  touch .gitkeep
fi
